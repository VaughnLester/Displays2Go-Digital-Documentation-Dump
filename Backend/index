const http = require('http'); 
const mysql = require('mysql2'); 
const urlParsing = require('url'); 
const fs = require('fs'); 
const querystring = require('node:querystring');
const formidable = require('formidable');
const { Blob } = require('buffer');
const path = require('path');
const { Buffer } = require('node:buffer');
const FileReader = require('FileReader');

const server = http.createServer((request, response)=>{
    const url = request.url;
    const method = request.method;
    const parsedUrl = urlParsing.parse(url, true)

    if (url == "/newSKU"){
        let body = '';
        request.on('data', chunk =>{ //using this to grab data from the url because it's needed for the server response.
        //in request.on , data is the event, each event is triggered differently 
        //request.on simply adds event listeners to the request, triggered at different events!
        body += chunk.toString();
        });
        request.on('end', ()=>{
        const parsedData = querystring.parse(body);
        response.writeHead(200, {  
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        const jsonString = JSON.stringify(parsedData);
        const jsonObject = JSON.parse(jsonString);
        const newSKU = jsonObject.sku
        connection.query(`CREATE TABLE ${newSKU} (entryID int NOT NULL AUTO_INCREMENT, Title varchar(255), Entry varchar(255) NOT NULL, PRIMARY KEY (entryID));`, (err, results) =>{
            if (err) {console.log(err); return;}
            else {console.log(`${newSKU} added to database!`);}})
            response.end();
        });
    }


    //saving file to database as blob 
    else if (url == "/upload"){
        
        const form = new formidable.IncomingForm();
        form.parse(request, (err, fields, files)=>{
            response.writeHead(200, {  
            'Content-Type': 'text/html',
            'Access-Control-Allow-Origin' : '*'});
            if(err){response.end("error parsing the file"); return;}
            
            const file = files.filetoupload;
            const filename = "Hello World!.txt";
            const filepath = path.join(__dirname, 'uploads', filename);
            console.log("file is here: " +file);
            console.log("file path is here: "+filepath);

            if(!file){
                response.end("no file uploaded");
                return;
            }

            fs.readFile('C:\\Users\\vaugh\\AppData\\Local\\Temp\\nfwpb7ozqhoap6pub8tmjnimo', (err,data) => {
                if(err){response.end("error reading the file"); console.log(err);return;}

                const sql = 'INSERT INTO files (filename, data) VALUES (?, ?)';
                connection.query(sql, [ filepath, data], (err, results)=>{
                    if(err){response.end("error saving file to database"); console.log(err); return;}

                    response.end("file uploaded and saved to database");
                });
            })
        })
    }
//to read the blob file 
    else if (url == "/read"){
        // response.writeHead(200, {  
        // 'Content-Type': 'text/html',
        // 'Access-Control-Allow-Origin' : '*'});
        connection.query(`SELECT * FROM files`, (err, results) =>{
        if (err) {console.log(err); return;}
        else {
            // // console.log(results);
            // // console.log(results.data); 
            // // console.log(results[0]);
            // console.log(results[0].data); //this one pulls the data 
            // console.log(Buffer);
            // const x = Buffer.from(results[0].data);
            // console.log(Buffer.from(results[0].data))
            // fs.readFile(x, (err, data) => {
            //     if (err) {
            //         console.log(err);
            //         response.end(err);
            //         return;
            //     }
            //     response.end(data);
            // });         


            //confirm the pdf file is saving fine, then see why it's not OPENING (sent to browser) fine
                async function convertBlobToPdf(blob, filePath) {
                try {
                    const arrayBuffer = await blob.arrayBuffer();
                    const buffer = Buffer.from(arrayBuffer);
                    response.setHeader('Content-Type', blob.type);
                    response.setHeader('Content-Disposition', `inline; filename="my PDF File"`);
                    response.end();

                    fs.writeFileSync(filePath, buffer);
                    console.log(`PDF file saved to ${filePath}`);
                } catch (error) {
                    console.error('Error converting Blob to PDF:', error);
                }
                }

            async function example() {
            // Simulate a Blob (replace with your actual Blob data)
                const blobData = new Uint8Array(results[0].data);
                const blob = new Blob([blobData], { type: 'application/pdf' });
            
            const pdfFilePath = 'output.pdf';
            await convertBlobToPdf(blob, pdfFilePath);
            }
            example();

        }})
    }

    // else if (url == "/blob"){
    //         response.writeHead(200, {  
    //     'Content-Type': 'text/html',
    //     'Access-Control-Allow-Origin' : '*'});
    //     connection.query("SELECT data FROM files", (err,results) =>{
    //         if (err){console.log(err); return;}
    //         else {
    //                             console.log(results);
    //             console.log(JSON.parse(JSON.stringify(results)));
    //             response.end(JSON.parse(JSON.stringify(results)));}
    //     })
    // }

    else if (url == "/deleteSKU"){
        let body = '';
        request.on('data', chunk =>{ 
        body += chunk.toString();
        });
        request.on('end', ()=>{
        const parsedData = querystring.parse(body);
        response.writeHead(200, {  
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        const jsonString = JSON.stringify(parsedData);
        const jsonObject = JSON.parse(jsonString);
        const deleteSKU = jsonObject.sku
        connection.query(`DROP TABLE ${deleteSKU}`, (err, results) =>{
            if (err) {console.log(err); return;}
            else {console.log(`${deleteSKU} deleted from database!`);}})
            response.end();
        });
    }

    else if (url == "/changeSKU"){
        let body = '';
        request.on('data', chunk =>{ 
        body += chunk.toString();
        });
        request.on('end', ()=>{
        const parsedData = querystring.parse(body);
        response.writeHead(200, {  
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        const jsonString = JSON.stringify(parsedData);
        const jsonObject = JSON.parse(jsonString);
        const currentSKU = jsonObject.sku;
        const updatedSKU = jsonObject.newSKU;
        connection.query(`RENAME TABLE ${currentSKU} to ${updatedSKU}`, (err, results) =>{
            if (err) {console.log(err); return;}
            else {console.log(`${currentSKU} changed to ${updatedSKU}!`);}})
            response.end();
        });
    }

    else if (url == "/addEntry"){
        let body = '';
        request.on('data', chunk =>{ 
        body += chunk.toString();
        });
        request.on('end', ()=>{
        const parsedData = querystring.parse(body);
        response.writeHead(200, {  
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        const jsonString = JSON.stringify(parsedData);
        const jsonObject = JSON.parse(jsonString);
        const addEntrySKU = jsonObject.sku;
        const addEntryTitle = jsonObject.title;
        const addEntryEntry = jsonObject.skuEntry;
        connection.query(`INSERT INTO ${addEntrySKU} (Title, Entry) VALUES ("${addEntryTitle}", "${addEntryEntry}")`, (err, results) =>{
            if (err) {console.log(err); return;}
            else {console.log(`${addEntryTitle} added to ${addEntrySKU}!`);}})
        response.end();
        });
    }

    else if (url == "/updateTitle"){
        let body = '';
        request.on('data', chunk =>{ 
        body += chunk.toString();
        });
        request.on('end', ()=>{
        const parsedData = querystring.parse(body);
        response.writeHead(200, {  
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        const jsonString = JSON.stringify(parsedData);
        const jsonObject = JSON.parse(jsonString);
        const updateTitleSKU = jsonObject.sku;
        const updateTitle1 = jsonObject.title;
        const updateTitle2 = jsonObject.updatedTitle;
        connection.query(`UPDATE ${updateTitleSKU} SET title = "${updateTitle2}" WHERE title = "${updateTitle1}"`, (err, results) =>{
            if (err) {console.log(err); return;}
            else {console.log(`${updateTitle1} updated to ${updateTitle2} in ${updateTitleSKU}`);}})
        response.end();
        });
    }

    else if (url == "/updateEntry"){
        let body = '';
        request.on('data', chunk =>{ 
        body += chunk.toString();
        });
        request.on('end', ()=>{
        const parsedData = querystring.parse(body);
        response.writeHead(200, {  
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        const jsonString = JSON.stringify(parsedData);
        const jsonObject = JSON.parse(jsonString);
        const updateSkuEntrySKU = jsonObject.sku;
        const updateSkuEntryTitle = jsonObject.title;
        const updateSkuEntryEntry = jsonObject.skuEntry;
        connection.query(`UPDATE ${updateSkuEntrySKU} SET entry = "${updateSkuEntryEntry}" WHERE title = "${updateSkuEntryTitle}"`, (err, results) =>{
            if (err) {console.log(err); return;}
            else {console.log(`${updateSkuEntryTitle} updated in ${updateSkuEntrySKU} to ${updateSkuEntryEntry}!`);}
        })
        response.end();
        });
    }

    else if (url == "/deleteData"){
        let body = '';
        request.on('data', chunk =>{ 
        body += chunk.toString();
        });
        request.on('end', ()=>{
        const parsedData = querystring.parse(body);
        response.writeHead(200, {  
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        const jsonString = JSON.stringify(parsedData);
        const jsonObject = JSON.parse(jsonString);
        const deleteSkuEntrySKU = jsonObject.sku;
        const deleteSkuEntryTitle = jsonObject.title;
        connection.query(`DELETE FROM ${deleteSkuEntrySKU} WHERE title = "${deleteSkuEntryTitle}"`, (err, results) =>{
            if (err) {console.log(err); return;}
            else {console.log(`${deleteSkuEntryTitle} deleted from ${deleteSkuEntrySKU}!`);}
        })
        response.end();
        });
    }

    else if (url == "/databasePull"){
        connection.query('SHOW TABLES;', (err,results) =>{ 
            response.writeHead(200, {
            'Content-Type': 'text/html',
            'Access-Control-Allow-Origin' : '*'});
            if (err){console.log(err); response.end('error fetching data'); return;
            }
            else{
                jsonString = JSON.stringify(results);
                jsonObject = JSON.parse(jsonString);
                response.write(readTables(jsonObject));
                response.end();
            }
        });
    }

    else if (parsedUrl.pathname == "/confirmation"){
        response.writeHead(200, {
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        fs.readFile('confirmation.html', function(err,content){
        if(err){console.log(err);response.end();}
        else{
            response.end(content);
        }})
    }

    else if (url == "/database"){
        response.writeHead(200, {
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});
        fs.readFile('database.html', function(err,content){
        if(err){
        console.log(err);
        response.end;
        }
        else{
        response.end(content);
        }
        })
    }

    else if (parsedUrl.pathname == "/table"){
        let body = " ";
        request.on('data', chunk => {body += chunk.toString()})//determines what happens on request (when the path/link is clicked), if you don't put anything here, it will just load endlessly becasuse it dosn't know what to do on the request - i think this is becasue your using the path name /table, but then you have more data to it as well that needs to be handled
        request.on('end', ()=>{
            response.writeHead(200, {  
            'Content-Type': 'text/html',
            'Access-Control-Allow-Origin' : '*'});
            const searchParams = new URLSearchParams(parsedUrl.search);   
            const tableName = searchParams.get('name');
            connection.query(`SELECT * FROM ${tableName}`, (err, results) =>{
            if (err) {console.log("error inserting data into database "+ err); return;}
            else {
            console.log(`Table request for ${tableName} successful!`);
            jsonString = JSON.stringify(results)
            jsonObject = JSON.parse(jsonString)
            //returns the entire HTML page
            //here, the readRows function filters through the jsonObject parameters and ADDS <li></li> HTML to each section!
            //From there, the function is used directly in the HTML code to manipulate it properly on the HTML page to be returned!
            //WARNING - The variables created outsided the manually written HTML cannot be accessed in the SCRIPT of the manually written HTML, but can be accessed in the BODY of the manually written HTML!
            response.end(`    
            <!DOCTYPE html>
            <html>
                <head>
                    <title>Display Array</title>
                </head>
                <body>
                    <h1>${tableName}</h1>
                    <ul id="myList2"></ul>
                    ${readRows(jsonObject)} 
                </body>
                <script>




                    
                </script>
            </html>`);
        }})})
    }

    else {
        response.writeHead(200, {
        'Content-Type': 'text/html',
        'Access-Control-Allow-Origin' : '*'});//enables CORS
        //fs.createReadStream('index.html').pipe(response);
        fs.readFile('index.html', function(err, content){
        if (err){console.log("error occurred trying to send html file"); response.end("error fetching index.html home file")}
        else {
            response.end(content);
        }})
    }
});//end server

//creating database connection, hosted on freesqldatabase.com
const connection = mysql.createConnection({
host:'sql5.freesqldatabase.com',
user: 'sql5768538',
password: '9np9VjdEks',
database: 'sql5768538'
});

//connecting database
connection.connect(function(err){
    if (err){console.log("error occurred while attempting connection: ", err)}
    else {console.log("database connection successful!")}
});

//connecting server
server.listen(5001, console.log("server is listening on 5001"));


//-------------------------------------------------------------------
//functions used:
//grab data from each row in database, add list item HTML
function readRows(arr){
    let max = arr.length -1;
    let results = ' ';
    while (max > -1){
    //normal line for all sku table, temp disabled for testing
    //results += `<li>${arr[max].Title}: ${arr[max].Entry}</li> `
    
    //new line for testing file table - temp testing
    results += 
    `<li>${arr[max].filename}: ${arr[max].data}</li>`
    max--;
    }
    return results;
}
//read each table 
function readTables(arr){
    let max = arr.length -1;
    let results = ' ';
    while (max > -1){
    results += `${arr[max].Tables_in_sql5768538}, `;
    //add link event listener -> goes to path that opens the table
    
    max--;
    }
    return results;
}

async function convertBlobToPdf(blobData) {
    try {
    const buffer = Buffer.from(await blobData.arrayBuffer());

    fs.writeFileSync("new file path", buffer);
    console.log("PDF file saved");
    } catch (error) {
    console.error('Error converting Blob to PDF:', error);
    }
}      


    const data = 'Hello, Blob!';
    const blob = new Blob([data], { type: 'text/plain' });
    console.log(blob);


